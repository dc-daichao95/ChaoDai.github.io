<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录一个基于k8s的helm-openstack问题</title>
      <link href="/2019/08/01/ji-lu-yi-ge-ji-yu-k8s-de-helm-opensatck-wen-ti/"/>
      <url>/2019/08/01/ji-lu-yi-ge-ji-yu-k8s-de-helm-opensatck-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="平台环境："><a href="#平台环境：" class="headerlink" title="平台环境："></a>平台环境：</h2><p>目前是在k8s环境下搭建的单master三个node节点的helm-在openstack(Ocata)</p><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>在K8S集群中配置的openstack环境使用novnc时（包括一体化和原生horizon）存在一定的问题，连接Novnc时会出现noVNC - Failed to connect to server (code: 1006)的错误（一般是很长时间没有使用novnc的情况下会出现此错误，正常连续点击连接novnc可正常运行）</p><h2 id="目前的解决办法："><a href="#目前的解决办法：" class="headerlink" title="目前的解决办法："></a>目前的解决办法：</h2><p>如果间隔很长时间使用novnc时（使用RESTful API）会连续调用三次novnc的API并弃用前两次的结果，经验证可行。</p><h2 id="目前的问题："><a href="#目前的问题：" class="headerlink" title="目前的问题："></a>目前的问题：</h2><p>希望研究清楚问题的原因，即从openstack源码角度进行分析，以及调查清楚是否是K8S环境下配置openstack导致的此异常</p><h2 id="目前进展："><a href="#目前进展：" class="headerlink" title="目前进展："></a>目前进展：</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ul><li>1.通过登录<a href="http://10.141.209.208:31000" target="_blank" rel="noopener">http://10.141.209.208:31000</a> （域default, 账号admin, 密码password）打开任意虚拟机的VNC控制台（会出现10006连接失败的错误，但不是必出现，可反复在各种情况下验证为何出现）；</li><li>2.然后在出现的时候连接实验室机房K8S环境master节点(10.141.209.209)获得名为openstack的namespace下的nova的pod的名字（命令kubectl get pods -n openstack| grep nova），根据名字查看nova的consoleauth和novncproxy的logs(命令kubectl logs [pods名] -n openstack)，分析日志相关内容；</li><li>3.根据日志定位到nova代码中consoleauth相关的部分，可以看到consoleauth/manager.py里authorize_console等函数里的LOG.info和日志里的内容匹配，因此可以在此处加上类似的打印日志的代码用于后期定位和解决1中出现的错误；</li><li>4.根据2中获得的信息可以知道nova的pods的容器在K8S的node节点(10.141.209.219)上，登录进此机器，通过docker ps | grep nova获得对应容器的具体信息，记录好容器的id，将3中修改后的文件通过docker cp或docker exec -it -u 0等方式替换容器中的内容（代码目录在容器内/var/lib/openstack/lib/python2.7/site-packages/nova/）；</li><li>5.在K8S的node节点(10.141.209.219)里通过docker save备份原生的nova镜像（通过docker images | grep nova获得）,备份完后通过docker commit生成和备份的镜像同名且同标签（即tag）的镜像，此时原来的镜像的标签会变成<none>，新的镜像（目前版本的话新镜像的标签为ocata）会依赖于于旧镜像<none>，所以目前无法删除<none>标签的镜像（以后可以通过导出等其他操作而不是commit避免目前的依赖问题）；</none></none></none></li><li>6.回到K8S环境master节点(10.141.209.209)，通过删除命令(kubectl delete pod [pod名]-n openstack)删除novaproxy和consoleauth相关pods, k8s集群会自动根据刚才改动的重启此时删除的pods的服务，通过1中命令重新查看pods状态直到正常；</li><li>7.再回到K8S的node节点(10.141.209.219)里通过docker exec -it -u 0进入容器核实改动，此实再回到<a href="http://10.141.209.208:31000" target="_blank" rel="noopener">http://10.141.209.208:31000</a> 使之出现异常，重新类似1中操作查看日志是否出现新加入代码中加入的自定义日志信息；</li><li>8.若一切正常，此时便完成了替换k8s/helm环境下pods服务的工作（nova相关的pods都是基于同一个nova镜像，所以理论上应把所有nova相关的pods删除重启保持一致，目前如果无影响可以不用），然后的工作就是进一步分析代码中的mc (即memcache)和authorize_console解决分析异常。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX相关</title>
      <link href="/2019/08/01/latex-xiang-guan/"/>
      <url>/2019/08/01/latex-xiang-guan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>容器漏洞CVE-cve-2019-5736</title>
      <link href="/2019/07/27/rong-qi-lou-dong-cve-cve-2019-5736/"/>
      <url>/2019/07/27/rong-qi-lou-dong-cve-cve-2019-5736/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2019年2月11日，runC的维护团队报告了一个新发现的漏洞，该漏洞最初由Adam Iwaniuk和Borys Poplawski发现。该漏洞编号为CVE-2019-5736，漏洞影响在默认设置下运行的Docker容器，并且攻击者可以使用它来获得主机上的root级访问权限。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>openstack-helm安装</title>
      <link href="/2019/04/05/openstack-helm-an-zhuang/"/>
      <url>/2019/04/05/openstack-helm-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Helm安装"><a href="#1-Helm安装" class="headerlink" title="1. Helm安装"></a>1. Helm安装</h2><h4 id="在连上外网的情况下："><a href="#在连上外网的情况下：" class="headerlink" title="在连上外网的情况下："></a>在连上外网的情况下：</h4><pre><code>$ curl https://raw.githubusercontent.com/helm/helm/master/scripts/get &gt; get_helm.sh$ chmod 700 get_helm.sh$ ./get_helm.sh</code></pre><h4 id="无法连上外网："><a href="#无法连上外网：" class="headerlink" title="无法连上外网："></a>无法连上外网：</h4><p>下载helm-v2.13.1-linux-amd64.tar.gz，解压并将helm复制到/usr/local/bin/</p><pre><code>helm init --upgrade --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</code></pre><h4 id="给tiller在k8s中授权："><a href="#给tiller在k8s中授权：" class="headerlink" title="给tiller在k8s中授权："></a>给tiller在k8s中授权：</h4><pre><code>kubectl create serviceaccount --namespace kube-system tillerkubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tillerkubectl patch deploy --namespace kube-system tiller-deploy -p &#39;{&quot;spec&quot;:{&quot;template&quot;:{&quot;spec&quot;:{&quot;serviceAccount&quot;:&quot;tiller&quot;}}}}&#39;</code></pre><h4 id="安装tiller："><a href="#安装tiller：" class="headerlink" title="安装tiller："></a>安装tiller：</h4><pre><code>yum install socat（k8s的所有节点安装）helm init --upgrade</code></pre><h4 id="看到helm和tiller两个都在运行："><a href="#看到helm和tiller两个都在运行：" class="headerlink" title="看到helm和tiller两个都在运行："></a>看到helm和tiller两个都在运行：</h4><pre><code>helm version</code></pre><h2 id="2-建立helm的openstack-charts"><a href="#2-建立helm的openstack-charts" class="headerlink" title="2. 建立helm的openstack-charts"></a>2. 建立helm的openstack-charts</h2><h4 id="手动建立ClusterRoleBindings："><a href="#手动建立ClusterRoleBindings：" class="headerlink" title="手动建立ClusterRoleBindings："></a>手动建立ClusterRoleBindings：</h4><p>由于使用kubernetes rbac，而目前openstack helm有bug，不正确建立服务帐户的clusterRolebindings，因此要手动建立。</p><pre><code>kubectl create -f &lt;(cat &lt;&lt;EOFapiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata:  name: ceph-sa-adminroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:  - apiGroup: rbac.authorization.k8s.io    kind: User    name: system:serviceaccount:ceph:defaultEOF)</code></pre><pre><code>kubectl create -f &lt;(cat &lt;&lt;EOFapiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata:  name: openstack-sa-adminroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:  - apiGroup: rbac.authorization.k8s.io    kind: User    name: system:serviceaccount:openstack:defaultEOF)</code></pre><p>将subject绑定到role；如上述代码，roleref是cluster-admin，一个默认admin角色，将用户User(:system:serviceaccount:ceph:default)绑定为此种角色。</p><h4 id="添加helm的本地repo："><a href="#添加helm的本地repo：" class="headerlink" title="添加helm的本地repo："></a>添加helm的本地repo：</h4><pre><code>helm serve &amp;helm repo add local http://localhost:8879/charts</code></pre><h4 id="从github获取charts的源码"><a href="#从github获取charts的源码" class="headerlink" title="从github获取charts的源码"></a>从github获取charts的源码</h4><pre><code>git clone https://github.com/openstack/openstack-helm-infra.gitgit clone https://github.com/openstack/openstack-helm.git</code></pre><h4 id="charts的make："><a href="#charts的make：" class="headerlink" title="charts的make："></a>charts的make：</h4><p>cd 两个目录，make即可；<br>  helm search可以看到很多local/下面的charts。</p><h2 id="部署coreDNS"><a href="#部署coreDNS" class="headerlink" title="部署coreDNS"></a>部署coreDNS</h2><h4 id="需要编辑5个yaml文件（参考）："><a href="#需要编辑5个yaml文件（参考）：" class="headerlink" title="需要编辑5个yaml文件（参考）："></a>需要编辑5个yaml文件（<a href="https://blog.51cto.com/ylw6006/2108426" target="_blank" rel="noopener">参考</a>）：</h4><pre><code>coredns-sa.yamlcoredns-rbac.yamlcoredns-configmap.yamlcoredns-deployment.yamlcoredns-service.yaml</code></pre><h4 id="上面五个文件都创建"><a href="#上面五个文件都创建" class="headerlink" title="上面五个文件都创建"></a>上面五个文件都创建</h4><pre><code>kubectl create -f .</code></pre><h4 id="Debug："><a href="#Debug：" class="headerlink" title="Debug："></a>Debug：</h4><p>  在coredns-deployment.yaml中，有ImagePullPolicy这个标记，有三个参数：Always 、Never 、IfNotPresent</p><ul><li>Always：不管镜像是否存在都会进行一次拉取。</li><li>Never：不管镜像是否存在都不会进行拉取</li><li>IfNotPresent：只有镜像不存在时，才会进行镜像拉取。<br>一般默认为IfNotPresent，但:latest标签的镜像默认为Always。因为我们不连外网，所以必须修改为IfNotPresent</li></ul><h2 id="标记nodes"><a href="#标记nodes" class="headerlink" title="标记nodes"></a>标记nodes</h2><h4 id="全部标记"><a href="#全部标记" class="headerlink" title="全部标记"></a>全部标记</h4><pre><code>kubectl label nodes ceph-osd=enabled --allkubectl label nodes ceph-mds=enabled --allkubectl label nodes ceph-mgr=enabled --allkubectl label nodes openvswitch=enabled --allkubectl label nodes openstack-compute-node=enabled --all</code></pre><h4 id="如果需要删除不需要标记的："><a href="#如果需要删除不需要标记的：" class="headerlink" title="如果需要删除不需要标记的："></a>如果需要删除不需要标记的：</h4><pre><code>kubectl label node x.x.x.x openvswitch-</code></pre><h4 id="控制节点标记一个网络性能好的："><a href="#控制节点标记一个网络性能好的：" class="headerlink" title="控制节点标记一个网络性能好的："></a>控制节点标记一个网络性能好的：</h4><pre><code>kubectl label node 10.141.209.214 openstack-control-plane=enabled</code></pre><h4 id="Mon和rgw分别选择3个点和2个点部署"><a href="#Mon和rgw分别选择3个点和2个点部署" class="headerlink" title="Mon和rgw分别选择3个点和2个点部署"></a>Mon和rgw分别选择3个点和2个点部署</h4><pre><code>kubectl label node x.x.x.x ceph-mon=enabledkubectl label node x.x.x.x ceph-rgw=enabled</code></pre><h4 id="查看-label："><a href="#查看-label：" class="headerlink" title="查看 label："></a>查看 label：</h4><pre><code>单个node：kubectl label node 10.141.209.214 --list所有node：kubectl get nodes --show-labels=true</code></pre><h4 id="取消master节点的taint（无法建立pod）"><a href="#取消master节点的taint（无法建立pod）" class="headerlink" title="取消master节点的taint（无法建立pod）"></a>取消master节点的taint（无法建立pod）</h4><pre><code>kubectl taint nodes --all node-role.kubernetes.io/master-</code></pre><h2 id="安装ceph"><a href="#安装ceph" class="headerlink" title="安装ceph"></a>安装ceph</h2><h4 id="Ceph的安装需要四个helm的chart-ip地址为物理机地址"><a href="#Ceph的安装需要四个helm的chart-ip地址为物理机地址" class="headerlink" title="Ceph的安装需要四个helm的chart(ip地址为物理机地址)"></a>Ceph的安装需要四个helm的chart(ip地址为物理机地址)</h4><pre><code>ceph-monhelm install --namespace=ceph local/ceph-mon --name=ceph-mon \  --set endpoints.identity.namespace=openstack \  --set endpoints.object_store.namespace=ceph \  --set endpoints.ceph_mon.namespace=ceph \  --set ceph.rgw_keystone_auth=true \  --set network.public=172.16.2.0/24 \  --set network.cluster=172.16.2.0/24 \  --set deployment.storage_secrets=true \  --set deployment.ceph=true \  --set deployment.rbd_provisioner=true \  --set deployment.client_secrets=false \  --set deployment.rgw_keystone_user_and_endpoints=false \  --set bootstrap.enabled=true</code></pre><pre><code>Ceph-osdhelm install --namespace=ceph local/ceph-osd --name=ceph-osd \  --set endpoints.identity.namespace=openstack \  --set endpoints.object_store.namespace=ceph \  --set endpoints.ceph_mon.namespace=ceph \  --set ceph.rgw_keystone_auth=true \  --set network.public=172.16.2.0/24 \  --set network.cluster=172.16.2.0/24 \  --set deployment.storage_secrets=true \  --set deployment.ceph=true \  --set deployment.rbd_provisioner=true \  --set deployment.client_secrets=false \  --set deployment.rgw_keystone_user_and_endpoints=false \  --set bootstrap.enabled=true</code></pre><pre><code>cd openstack./tools/deployment/multinode/020-ingress.sh</code></pre><pre><code>Ceph-clienthelm install --namespace=ceph local/ceph-client --name=ceph-client \  --set endpoints.identity.namespace=openstack \  --set endpoints.object_store.namespace=ceph \  --set endpoints.ceph_mon.namespace=ceph \  --set ceph.rgw_keystone_auth=true \  --set network.public=172.16.2.0/24 \  --set network.cluster=172.16.2.0/24 \  --set deployment.storage_secrets=true \  --set deployment.ceph=true \  --set deployment.rbd_provisioner=true \  --set deployment.client_secrets=false \  --set deployment.rgw_keystone_user_and_endpoints=false \  --set bootstrap.enabled=true</code></pre><pre><code>Ceph-provisionershelm install --namespace=ceph local/ceph-provisioners --name=ceph-provisioners \  --set endpoints.identity.namespace=openstack \  --set endpoints.object_store.namespace=ceph \  --set endpoints.ceph_mon.namespace=ceph \  --set ceph.rgw_keystone_auth=true \  --set network.public=172.16.2.0/24 \  --set network.cluster=172.16.2.0/24 \  --set deployment.storage_secrets=true \  --set deployment.ceph=true \  --set deployment.rbd_provisioner=true \  --set deployment.client_secrets=false \  --set deployment.rgw_keystone_user_and_endpoints=false \  --set bootstrap.enabled=true</code></pre><h4 id="上述四个chart按照顺序创建："><a href="#上述四个chart按照顺序创建：" class="headerlink" title="上述四个chart按照顺序创建："></a>上述四个chart按照顺序创建：</h4><ul><li>ceph-mon</li><li>ceph-osd</li><li>Ceph-client</li><li>Ceph-provisioners</li></ul><h4 id="Debug：-1"><a href="#Debug：-1" class="headerlink" title="Debug："></a>Debug：</h4><ul><li>Ceph的启动需要rbd的内核模块<br>modprobe rbd</li><li>Ceph的残余内容，key等没有删除干净导致报错<br>所有node节点的/var/lib/openstack-helm/ceph 删除干净</li></ul><h2 id="安装openstack（mariadb-rabbitmq基础服务）"><a href="#安装openstack（mariadb-rabbitmq基础服务）" class="headerlink" title="安装openstack（mariadb+rabbitmq基础服务）"></a>安装openstack（mariadb+rabbitmq基础服务）</h2><pre><code>cd openstack-helm./tools/deployment/developer/ceph/045-ceph-ns-activate.sh(修改文件中的ip)./tools/deployment/developer/ceph/050-mariadb.sh./tools/deployment/developer/ceph/060-rabbitmq.sh</code></pre><h4 id="Debug：-2"><a href="#Debug：-2" class="headerlink" title="Debug："></a>Debug：</h4><ul><li><p>无法挂载</p><ul><li>1.控制节点yum update并yum install ceph-common</li><li>2.挂载找不到mon地址<br>  在物理机的/etc/hosts中添加ceph.mon 的地址<blockquote><p>如：cat /etc/hosts<br> 10.141.209.201 ceph-mon.ceph.svc.cluster.local</p></blockquote></li></ul></li><li><p>Rabbitmq等待时间过短导致启动失败： epmd error for host : (non-existing domain)</p><ul><li>在openstack-helm-infra/rabbitmq/templates/service-discover中修改：<br>metadata中：<blockquote><p>annotations:<br>  service.alpha.kubernetes.io/tolerate-unready-endpoints: “true”<br>spec中：<br>  publishNotReadyAddresses: true</p></blockquote></li></ul></li><li><p>Rabbitmq崩溃：<br>报错同上，但是原因其实是dns无法解析，修改dns的configmap，删除proxy一行。</p></li><li><p>Rabbitmq崩溃：<br>报错同上，但是原因其实是flannel网络出现问题，因为时间不同步导致renew lease时崩溃。</p></li></ul><h2 id="安装openstack（openvswitch等准备服务"><a href="#安装openstack（openvswitch等准备服务" class="headerlink" title="安装openstack（openvswitch等准备服务)"></a>安装openstack（openvswitch等准备服务)</h2><pre><code>cd openstack-helm-infra:helm install --name=memcached ./memcached --namespace=openstackhelm install --name=etcd-rabbitmq ./etcd --namespace=openstackhelm install --name=ingress ./ingress --namespace=openstackhelm install --name=libvirt ./libvirt --namespace=openstackLibvirt启动报错ERROR: libvirtd daemon already running on host解决方法： systemctl stop libvirtd  然后systemctl disable libvirtd关闭物理机的libvirtd服务helm install --name=openvswitch ./openvswitch --namespace=openstack</code></pre><h2 id="安装openstack（keystone等主要服务）"><a href="#安装openstack（keystone等主要服务）" class="headerlink" title="安装openstack（keystone等主要服务）"></a>安装openstack（keystone等主要服务）</h2><pre><code>cd openstack-helm./tools/deployment/multinode/080-keystone.sh./tools/deployment/multinode/090-ceph-radosgateway.sh（修改文件中的ip ）./tools/deployment/multinode/100-glance.sh  修改glance使用ceph rbd，在openstack-helm/glance/values.yaml第21行，修改为storage: rbd  由于100-glance.sh文件中也有对storage的配置，必须删除 tee /tmp/glance.yaml 文件中关于覆盖values文件storage的GLANCE_BACKEND那两行。./tools/deployment/developer/ceph/090-heat.sh./tools/deployment/developer/ceph/130-cinder.sh./tools/deployment/developer/ceph/100-h orizon.sh</code></pre><h2 id="安装openstack（nova-neutron计算服务）"><a href="#安装openstack（nova-neutron计算服务）" class="headerlink" title="安装openstack（nova+neutron计算服务）"></a>安装openstack（nova+neutron计算服务）</h2><pre><code>/tools/deployment/developer/ceph/160-compute-kit.sh  160-compute-kit.sh文件的修改，需要删除一些内容</code></pre><p>Nova的配置，修改nova/values.yaml文件：<br>  Nova使用ceph rbd做后端，第1497行改为images_type: rbd</p><p>  <img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/1.png" alt="图一"></p><p>在nova的values文件中，第203行，将30680对应的port从false改为true</p><p>  <img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/2.png" alt="图二"></p><p>为了方便调试，将nova的logs改为dubug模式，在第1531行， level: DEBUG</p><p>  <img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/3.png" alt="图三"></p><p>Vnc本身的网址是k8s内部地址，为了外部可用，在第1457行，我们添加如下字段：<br>   novncproxy_base_url: <a href="http://10.190.2.21:30680/vnc_auto.html" target="_blank" rel="noopener">http://10.190.2.21:30680/vnc_auto.html</a>   其中，IP地址是k8s集群某个主机的地址。</p><p>  <img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/4.png" alt="图四"></p><p>ceph的用于nova的pool vms可能需要自己手动创建</p><pre><code>ceph osd pool create vms 0ceph osd pool lsceph osd pool get-quota vmsceph osd pool application enable vms rbdceph osd pool application get vms</code></pre><p>Neutron的配置<br>配置物理网卡，在neutron/values.yaml文件中，进行如下修改（有可用网段，用vlan作为外网的时候）：</p><ul><li>network. auto_bridge_add  添加 br-physnet1: ens7f1</li></ul><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/5.png" alt="图五"></p><ul><li>conf. ml2_conf. plugins 取消掉队vlan的注释，并添加正确的external tag范围</li></ul><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/6.png" alt="图六"></p><ul><li>conf. openvswitch_agent. ovs的bridge_mappings，修改external对应的网卡</li></ul><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/7.png" alt="图七"></p><p>Neutron服务报错：<br>It may be the case that bridge and/or br_netfilter kernel modules are not loaded.<br>解决方法：重新编译centos的内核，需要版本新一点，我使用的是3.10.957的内核。</p><h2 id="使用openstack"><a href="#使用openstack" class="headerlink" title="使用openstack"></a>使用openstack</h2><h4 id="非必要）如果没有外网资源需要使用网桥："><a href="#非必要）如果没有外网资源需要使用网桥：" class="headerlink" title="(非必要）如果没有外网资源需要使用网桥："></a>(非必要）如果没有外网资源需要使用网桥：</h4><p>在有l3-agent的node节点，建立gateway.sh；文件内容如下，并运行（没有可用网段，只能使用自定义的外网的时候）</p><pre><code>#!/bin/bashset -xe# Assign IP address to br-exOSH_BR_EX_ADDR=&quot;172.24.4.1/24&quot;OSH_EXT_SUBNET=&quot;172.24.4.0/24&quot;sudo ip addr add ${OSH_BR_EX_ADDR} dev br-exsudo ip link set br-ex up# NOTE(portdirect): With Docker &gt;= 1.13.1 the default FORWARD chain policy is# configured to DROP, for the l3 agent to function as expected and for# VMs to reach the outside world correctly this needs to be set to ACCEPT.sudo iptables -P FORWARD ACCEPT# Setup masquerading on default route dev to public subnetDEFAULT_ROUTE_DEV=&quot;$(sudo ip -4 route list 0/0 | awk &#39;{ print $5; exit }&#39;)&quot;#DEFAULT_ROUTE_DEV=&quot;em2&quot;sudo iptables -t nat -A POSTROUTING -o ${DEFAULT_ROUTE_DEV} -s ${OSH_EXT_SUBNET} -j MASQUERADEsleep 1</code></pre><h4 id="设置externet（在客户端或者dashboard）创建外部网络："><a href="#设置externet（在客户端或者dashboard）创建外部网络：" class="headerlink" title="设置externet（在客户端或者dashboard）创建外部网络："></a>设置externet（在客户端或者dashboard）创建外部网络：</h4><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/8.png" alt="图八"></p><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/9.png" alt="图九"><br><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/10.png" alt="图十"></p><h4 id="使用openstack的虚拟机"><a href="#使用openstack的虚拟机" class="headerlink" title="使用openstack的虚拟机"></a>使用openstack的虚拟机</h4><p>首先安全组需要设置，一般加入以下四个规则</p><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/12.png" alt="图十二"></p><p>  创建实例时创建ssh的key，并下载，比如ssh-key.pem<br>  创建实例选择配置驱动<br>  因为ssh-key.pem文件的权限为644，无法登陆，用chmod将权限改为500<br>  使用ssh -i ssh-key.pem <a href="mailto:ubuntu@10.190.8.107" target="_blank" rel="noopener">ubuntu@10.190.8.107</a> 即可登陆</p><p>在浏览器中访问集群中任一节点的ip:31000；</p><p>主机管理：可以统计所有的计算节点</p><h4 id="其他debug："><a href="#其他debug：" class="headerlink" title="其他debug："></a>其他debug：</h4><p>Nova-compute服务出错，表现为dashboard虚拟机管理器这个节点：<br>  Log报错如图</p><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/helm-openstack/11.png" alt="图十一"></p><p>解决方法：自己mkdir 相应instances，touch一个disk.config文件，即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2018/06/03/markdown-yu-fa/"/>
      <url>/2018/06/03/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>维基百科对<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown</a>的介绍如下：</p><blockquote><p>Markdown是一种轻量级标记语言，创始人为約翰·格魯伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p></blockquote><p>由于个人对一些文档和基于Hexo的博客的需要（相较于LaTeX来写日常的文档更为简单好用），记录一下基本的语法（避免遗忘）。</p><ul><li>优点： 纯文本（只要支持Markdown都能获得一样的编辑效果），排版方便而且语法简单；</li><li>缺点： 有些平台不支持Markdown编辑模式。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>在想要设置为标题的文字前面加#来表示，一个#是一级标题，二个#是二级标题，以此类推。支持六级标题（标准语法一般在#后跟个空格再写文字）。</p><p>举个例子：</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h3 id="2-字体相关"><a href="#2-字体相关" class="headerlink" title="2. 字体相关"></a>2. 字体相关</h3><p>基本的字体可以进行<strong>加粗</strong>，<em>斜体</em>，<strong><em>斜体加粗</em></strong>，<del>删除线</del>，复杂的字体（<font size="2">字体大小</font>，<font color="green">字体颜色</font>，<font face="SimHei">字体格式</font>）需要嵌入html。</p><ul><li><p>加粗: 要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体: 要倾斜的文字左右分别用一个*号包起来</p></li><li><p>斜体加粗: 要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线: 要加删除线的文字左右分别用两个~~号包起来</p></li></ul><p>举个例子：</p><pre><code>**加粗***斜体****斜体加粗***~~删除线~~&lt;font size=&quot;2&quot;&gt;字体大小&lt;/font&gt;&lt;font color=&quot;green&quot;&gt;字体颜色&lt;/font&gt;&lt;font face=&quot;SimHei&quot;&gt;字体格式&lt;/font&gt;</code></pre><p>效果：</p><blockquote><p><strong>加粗</strong><br>  <em>斜体</em><br>  <strong><em>斜体加粗</em></strong><br>  <del>删除线</del><br>  <font size="2">字体大小</font><br>  <font color="green">字体颜色</font><br>  <font face="SimHei">字体格式</font></p></blockquote><p>附常见的中英文字体：</p><table><thead><tr><th align="center">字体</th><th align="center">名字</th></tr></thead><tbody><tr><td align="center"><font face="PMingLiU">新细明体</font></td><td align="center">PMingLiU</td></tr><tr><td align="center"><font face="MingLiU">细明体</font></td><td align="center">MingLiU</td></tr><tr><td align="center"><font face="DFKai-SB">标楷体</font></td><td align="center">DFKai-SB</td></tr><tr><td align="center"><font face="SimSun">宋体</font></td><td align="center">SimSun</td></tr><tr><td align="center"><font face="FangSong">仿宋</font></td><td align="center">FangSong</td></tr><tr><td align="center"><font face="KaiTi">楷体</font></td><td align="center">KaiTi</td></tr><tr><td align="center"><font face="SimHei">黑体</font></td><td align="center">SimHei</td></tr><tr><td align="center"><font face="Microsoft YaHei">微软雅黑体</font></td><td align="center">Microsoft YaHei</td></tr></tbody></table><table><thead><tr><th align="center">Font</th><th align="center">Face</th></tr></thead><tbody><tr><td align="center"><font face="Helvetica">Helvetica</font></td><td align="center">Helvetica</td></tr><tr><td align="center"><font face="Arial">Arial</font></td><td align="center">Arial</td></tr><tr><td align="center"><font face="Verdana">Verdana</font></td><td align="center">Verdana</td></tr><tr><td align="center"><font face="Impact">Impact</font></td><td align="center">Impact</td></tr><tr><td align="center"><font face="Times New Roman">Times New Roman</font></td><td align="center">Times New Roman</td></tr></tbody></table><hr><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h3><p>在引用的文字前加&gt;，引用也可以嵌套，如加&gt;&gt;或者&gt;&gt;&gt; 。</p><p>举个例子：</p><pre><code>&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容</code></pre><p>效果：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote><hr><h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h3><p>三个或者三个以上的 - 或者 * 。</p><p>举个例子：</p><pre><code>***---</code></pre><p>效果：</p><hr><hr><p>二者显示效果是一样</p><hr><h3 id="5-插入图片"><a href="#5-插入图片" class="headerlink" title="5. 插入图片"></a>5. 插入图片</h3><p>格式如下</p><pre><code>![图片alt](图片地址 &quot;图片title&quot;)</code></pre><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容（title可加可不加）。</p><p>举个例子：</p><pre><code>![Markdown](https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/1280px-Markdown-mark.svg.png &quot;Markdown&quot;)</code></pre><p>效果：</p><p><img src="https://raw.githubusercontent.com/dc-daichao95/dc-daichao95.github.io/hexo_bak/static/img/1280px-Markdown-mark.svg.png" alt="图片_Markdownalt" title="Markdown"></p><hr><h3 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h3><p>格式如下</p><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)</code></pre><p>title可加可不加<br>  举个例子：</p><pre><code>[GitHub](https://github.com/)[Google](https://www.google.com)</code></pre><p>  效果：</p><blockquote><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a><br>  <a href="https://www.google.com" target="_blank" rel="noopener">Google</a></p></blockquote><h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表用 - + * (注意空格)。<br>  举个例子：</p><pre><code>- The Fool+ Star Platinum* Golden Exp</code></pre><p>  效果：</p><ul><li>The Fool</li></ul><ul><li>Star Platinum</li></ul><ul><li>Golden Exp</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>数字加点（注意空格）。<br>  举个例子：</p><pre><code>1. King Crimson2. Aerosmith</code></pre><p>  效果：</p><ol><li>King Crimson</li><li>Aerosmith</li></ol><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>上一级和下一级之间敲三个空格即可。</p><hr><h3 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h3><p>格式：</p><pre><code>| 表头 | 表头 | 表头 | 表头 || - | :-: | -: | :-|| 内容 | 内容 | 内容 | 内容 || 内容 | 内容 | 内容 | 内容 |:-:居中-:右对齐:-左对齐</code></pre><p>举个例子：</p><pre><code>| Char | Stand | Power | Speed || - | :-: | -: | :- || Kujo Jotaro | Star Platinum | A | A || Kira Yoshikage | Killer Queen| A | B || Higashikata Josuke | Crazy Diamond | A | A |</code></pre><p>  效果:</p><table><thead><tr><th>Char</th><th align="center">Stand</th><th align="right">Power</th><th align="left">Speed</th></tr></thead><tbody><tr><td>Kujo Jotaro</td><td align="center">Star Platinum</td><td align="right">A</td><td align="left">A</td></tr><tr><td>Kira Yoshikage</td><td align="center">Killer Queen</td><td align="right">A</td><td align="left">B</td></tr><tr><td>Higashikata Josuke</td><td align="center">Crazy Diamond</td><td align="right">A</td><td align="left">A</td></tr></tbody></table><p>注意：<br>  表格前一行需空出。</p><hr><h3 id="9-代码"><a href="#9-代码" class="headerlink" title="9. 代码"></a>9. 代码</h3><h4 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h4><p>代码之间分别用一个反引号`包起来。<br>  举个例子：</p><pre><code>`内容`</code></pre><p>效果：<br>  <code>内容</code></p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码之间分别用三个反引号包起来，三个反引号单独占一行(头反引号加上语言可以实现语法高亮）。<br>  举个例子：</p><pre><code>(```cpp     加个了一个括号防止转义     #include  &lt;stdio.h&gt;     int main(void)`     {         printf(&quot;Hello world\n&quot;);     }(```</code></pre><p>效果：</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;stdio.h></span></span>   <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><hr><h2 id="基于atom打造顺手的Markdown编辑器"><a href="#基于atom打造顺手的Markdown编辑器" class="headerlink" title="基于atom打造顺手的Markdown编辑器"></a>基于atom打造顺手的Markdown编辑器</h2><h3 id="1-安装Atom"><a href="#1-安装Atom" class="headerlink" title="1. 安装Atom"></a>1. 安装Atom</h3><p>下载安装<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a></p><h3 id="2-有关Markdown的拓展"><a href="#2-有关Markdown的拓展" class="headerlink" title="2. 有关Markdown的拓展"></a>2. 有关Markdown的拓展</h3><ul><li><p>markdown-preview-plus<br>markdown-preview-plus对markdown-preview做了功能扩展和增强（需关闭markdown-preview）。</p><ul><li>持预览实时渲染。(Ctrl + Shift + M)</li><li>支持Latex公式。(Ctrl + Shift + X)</li></ul></li><li><p>markdown-table-editor<br>更方便的编辑Markdown的表格</p></li><li><p>markdown-themeable-pdf、pdf-view<br>提供pdf导出和预览功能</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建相关</title>
      <link href="/2018/05/29/bo-ke-da-jian-xiang-guan/"/>
      <url>/2018/05/29/bo-ke-da-jian-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Hexo搭建个人博客"><a href="#基于Hexo搭建个人博客" class="headerlink" title="基于Hexo搭建个人博客"></a>基于Hexo搭建个人博客</h2><h4 id="写在前面的一些介绍"><a href="#写在前面的一些介绍" class="headerlink" title="写在前面的一些介绍"></a>写在前面的一些介绍</h4><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo 快速、简洁且高效的博客框架</a>是一款基于Node.js的静态博客框架，可以方便的托管在GitHub上</p><h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><h4 id="一些主题"><a href="#一些主题" class="headerlink" title="一些主题"></a>一些主题</h4><p>主题页面：<a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a></p><h4 id="更新备份"><a href="#更新备份" class="headerlink" title="更新备份"></a>更新备份</h4><h5 id="更新博客文件"><a href="#更新博客文件" class="headerlink" title="更新博客文件"></a>更新博客文件</h5><p>常规来说更新Hexo的博客只需要在修改之后，hexo clean;<br>个人觉得比较麻烦，简单写了一个shell和expect的脚本（也可以用<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">crontab</a>定时自动备份）</p><ul><li><p>syn_blog.sh</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># 基于hexo的博客同步到github page的脚本</span>blog_home<span class="token operator">=</span><span class="token string">"/home/dc/Workspace/blog"</span>script_ge<span class="token operator">=</span><span class="token string">"/home/dc/Workspace/script/hexo_generate.expect"</span><span class="token punctuation">(</span>cd <span class="token variable">$blog_home</span><span class="token punctuation">;</span>hexo clean<span class="token punctuation">;</span>hexo g<span class="token punctuation">;</span> <span class="token function">expect</span> <span class="token variable">$script_ge</span><span class="token punctuation">)</span></code></pre></li><li><p>hexo_generate.expect</p><pre class=" language-sh"><code class="language-sh">#!/bin/expectset timeout 30set username "XXX@XXX.com"set passwd "XXXXXX"spawn hexo d  expect "Username for 'https://github.com':"  send "$username\r"  expect "Password for 'https://$username@github.com':"  send "$passwd\r"  interact</code></pre><h5 id="将博客目录下的源文件备份到github（虽然现在github也不稳了）"><a href="#将博客目录下的源文件备份到github（虽然现在github也不稳了）" class="headerlink" title="将博客目录下的源文件备份到github（虽然现在github也不稳了）"></a>将博客目录下的源文件备份到github（虽然现在github也不稳了）</h5><p>首先在github博客仓库下新建一个分支hexo_bak，然后git clone到本地，把.git文件夹放在博客目录下。</p><pre><code>查看远程分支$ git branch -a查看本地分支$ git branch切换分支$ git checkout -b hexo_bak添加和上传文件到本地仓库$ git add .$ git commit -m &quot;infos&quot;上传本地仓库(本分支第一次上传)$ git push --set-upstream origin hexo_bak</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
